#include "file_generator.h"
#include "../graph/node_graph.h"
#include "../graph/pipeline_node.h"
#include "../util/logger.h"

#include <algorithm>
#include <filesystem>
#include <fstream>
#include <print>
#include <set>
#include <sstream>

using std::print;

namespace {

// Sanitize a name for use as a C++ identifier (replace spaces with underscores, etc.)
std::string sanitizeName(const std::string& name) {
    std::string result = name;
    std::replace(result.begin(), result.end(), ' ', '_');
    return result;
}

// Inline template for main.cpp
constexpr const char* MAIN_TEMPLATE = R"cpp(// Generated Vulkan Application
// This file is auto-generated by Vulkan Editor

#include "vulkan_renderer.h"

int main(int argc, char* argv[]) {
    VulkanRenderer renderer;

    try {
        renderer.init();
        renderer.run();
        renderer.cleanupRenderer();
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}
)cpp";

// Inline template for vulkan_renderer.h
constexpr const char* RENDERER_TEMPLATE = R"cpp(// vim:foldmethod=marker
#pragma once

#include "primitives.h"

// VulkanRenderer class {{{
class VulkanRenderer : public VulkanBase {
public:
    VulkanRenderer() = default;
    ~VulkanRenderer() override = default;

    void init();
    void run();
    void cleanupRenderer();

    std::vector<Object>& getObjects() { return m_objects; }
    const std::vector<Object>& getObjects() const { return m_objects; }

    void loadModel(const std::string& modelPath, const std::string& texturePath);

protected:
    void onWindowResized() override;
    void onKeyEvent(const SDL_KeyboardEvent& event) override;
    void onMouseMotion(float x, float y) override;
    void onMouseButton(const SDL_MouseButtonEvent& event, Uint32 eventType) override;
    void onMouseScroll(float delta) override;

private:
    void initPrimitives();
    void setupPipelines();
    void setupDescriptors();
    void drawFrame();
    void updateUniformBuffers(uint32_t currentImage);
    void updateCameraAspectRatios();

    std::vector<Object> m_objects;
    std::chrono::steady_clock::time_point m_lastFrameTime;
    float m_deltaTime = 0.0f;
};
// }}}

// VulkanRenderer implementation {{{
inline void VulkanRenderer::init() {
    initWindow("Vulkan Renderer");
    initVulkan();
    initPrimitives();
    setupPipelines();
    setupDescriptors();
    updateCameraAspectRatios();

    m_lastFrameTime = std::chrono::steady_clock::now();
    showWindow();
}

inline void VulkanRenderer::run() {
    while (!shouldClose()) {
        auto currentTime = std::chrono::steady_clock::now();
        m_deltaTime = std::chrono::duration<float>(currentTime - m_lastFrameTime).count();
        m_lastFrameTime = currentTime;

        pollEvents();
// === CAMERA_KEYBOARD_PROCESSING ===

        if (!isMinimized()) {
            drawFrame();
        }
    }

    waitIdle();
}

inline void VulkanRenderer::cleanupRenderer() {
    cleanupPrimitives(getDevice(), getAllocator());
    cleanup();
}

inline void VulkanRenderer::initPrimitives() {
    const auto& swapChain = getSwapChain();
    VkExtent3D extent{
        .width = swapChain.extent.width,
        .height = swapChain.extent.height,
        .depth = 1
    };
    initializePrimitives(
        getPhysicalDevice(),
        getDevice(),
        getAllocator(),
        getGraphicsQueue(),
        getCommandPool(),
        extent,
        swapChain.imageFormat,
        std::span<const VkImage>(swapChain.images.data(), swapChain.images.size())
    );
}

inline void VulkanRenderer::setupPipelines() {}

inline void VulkanRenderer::setupDescriptors() {}

inline void VulkanRenderer::drawFrame() {
    uint32_t imageIndex = beginFrame();
    if (imageIndex == UINT32_MAX) {
        return;
    }

    updateUniformBuffers(getCurrentFrame());

    VkCommandBuffer cmd = getCurrentCommandBuffer();
    vkResetCommandBuffer(cmd, 0);

    VkCommandBufferBeginInfo beginInfo{
        .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
        .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT
    };

    if (vkBeginCommandBuffer(cmd, &beginInfo) != VK_SUCCESS) {
        throw std::runtime_error("Failed to begin recording command buffer!");
    }

    recordPrimitiveCommands(cmd, imageIndex);

    if (vkEndCommandBuffer(cmd) != VK_SUCCESS) {
        throw std::runtime_error("Failed to record command buffer!");
    }

    endFrame(imageIndex);
}

inline void VulkanRenderer::updateUniformBuffers(uint32_t) {}

inline void VulkanRenderer::updateCameraAspectRatios() {
    const auto& swapChain = getSwapChain();
    float aspectRatio = static_cast<float>(swapChain.extent.width) / static_cast<float>(swapChain.extent.height);
// === CAMERA_ASPECT_RATIO_UPDATE ===
}

inline void VulkanRenderer::onWindowResized() {
    cleanupPrimitives(getDevice(), getAllocator());
    initPrimitives();
    updateCameraAspectRatios();
}

inline void VulkanRenderer::onKeyEvent(const SDL_KeyboardEvent& event) {
    if (event.down && event.scancode == SDL_SCANCODE_ESCAPE) {
        // Close application on Escape
    }
}

inline void VulkanRenderer::onMouseMotion(float x, float y) {
// === CAMERA_MOUSE_MOTION ===
}

inline void VulkanRenderer::onMouseButton(const SDL_MouseButtonEvent& event, Uint32 eventType) {
// === CAMERA_MOUSE_BUTTON ===
}

inline void VulkanRenderer::onMouseScroll(float delta) {
// === CAMERA_MOUSE_SCROLL ===
}

inline void VulkanRenderer::loadModel(const std::string&, const std::string&) {}
// }}}
)cpp";

} // namespace

void FileGenerator::generateProject(
    NodeGraph& graph,
    primitives::Store& store,
    const std::filesystem::path& outputDirectory
) {
    std::filesystem::path generatedDir = outputDirectory;
    std::filesystem::path projectRoot = generatedDir.parent_path();
    std::filesystem::path srcDir = projectRoot / "src";

    // Create directory structure
    std::filesystem::create_directories(generatedDir);
    std::filesystem::create_directories(srcDir);

    // Validate primitive names
    store.validateUniqueNames();

    // Build dependencies for struct generation
    graph.buildDependencies();

    // Generate only project-specific files (shared code is now in vkDuck)
    generateCameraInstances(store, generatedDir);
    generatePrimitives(graph, store, generatedDir);
    generateRenderer(store, generatedDir);
    generateShaders(store, projectRoot / "compiled_shaders");

    // Generate main.cpp in src/
    generateMain(srcDir);

    // Generate subproject wrap file and meson.build at project root
    generateWrapFile(projectRoot);
    generateMesonBuild(store, projectRoot);

    Log::info("FileGenerator", "Project generated to: {}", projectRoot.string());
}

void FileGenerator::generateWrapFile(const std::filesystem::path& projectRoot) {
    namespace fs = std::filesystem;

    // Create subprojects directory
    fs::path subprojectsDir = projectRoot / "subprojects";
    fs::create_directories(subprojectsDir);

    // Get the path to the editor's vkDuck library
    // The library is now in subprojects/vkDuck (shared with the editor)
    fs::path editorRoot = fs::current_path();
    fs::path vkDuckLibPath = editorRoot / "subprojects" / "vkDuck";

    // For local development: create a symlink to vkDuck
    // This works on both macOS and Linux
    fs::path linkPath = subprojectsDir / "vkDuck";

    // Remove existing link/directory if present
    std::error_code ec;
    if (fs::exists(linkPath, ec) || fs::is_symlink(linkPath)) {
        fs::remove_all(linkPath, ec);
        if (ec) {
            Log::warning("FileGenerator", "Could not remove existing path: {}", ec.message());
        }
    }

    // Create symlink (works on macOS, Linux, and Windows with appropriate permissions)
    try {
        fs::create_directory_symlink(vkDuckLibPath, linkPath);
        Log::info("FileGenerator", "Created symlink: {} -> {}", linkPath.string(), vkDuckLibPath.string());
    } catch (const fs::filesystem_error& e) {
        // Symlink creation failed - try copying as fallback (especially useful on Windows)
        Log::warning("FileGenerator", "Symlink failed ({}), copying directory instead", e.what());
        try {
            fs::copy(vkDuckLibPath, linkPath, fs::copy_options::recursive | fs::copy_options::overwrite_existing);
            Log::info("FileGenerator", "Copied vkDuck to: {}", linkPath.string());
        } catch (const fs::filesystem_error& copyError) {
            Log::error("FileGenerator", "Failed to copy vkDuck: {}", copyError.what());
            return;
        }
    }

    // Also generate a wrap-git file for distribution (when project is shared via git)
    // Users can uncomment this and remove the symlink to fetch from remote
    auto wrapFile = subprojectsDir / "vkDuck.wrap.example";
    std::ofstream out(wrapFile, std::ios::trunc);
    if (out.is_open()) {
        print(out, "# Example wrap file for fetching vkDuck from git\n");
        print(out, "# To use: rename this file to vkDuck.wrap and remove the vkDuck/ directory\n");
        print(out, "[wrap-git]\n");
        print(out, "directory = vkDuck\n");
        print(out, "url = https://github.com/your-username/Vulkan-Editor.git\n");
        print(out, "revision = head\n");
        print(out, "depth = 1\n");
        print(out, "clone-recursive = false\n\n");
        print(out, "[provide]\n");
        print(out, "vkDuck = vkDuck_dep\n");
        Log::info("FileGenerator", "Generated example wrap file: {}", wrapFile.string());
    }

    // Copy dependency wrap files that vkDuck needs
    // vkDuck's meson.build uses dependency() calls that need these wraps
    fs::path editorSubprojects = editorRoot / "subprojects";

    // List of wrap files to copy
    std::vector<std::string> wrapFiles = {
        "vulkan-memory-allocator.wrap",
        "sdl3.wrap",
        "glm.wrap"
    };

    for (const auto& wrapName : wrapFiles) {
        fs::path srcWrap = editorSubprojects / wrapName;
        fs::path dstWrap = subprojectsDir / wrapName;
        if (fs::exists(srcWrap)) {
            try {
                fs::copy_file(srcWrap, dstWrap, fs::copy_options::overwrite_existing);
                Log::info("FileGenerator", "Copied wrap file: {}", wrapName);
            } catch (const fs::filesystem_error& e) {
                Log::warning("FileGenerator", "Failed to copy {}: {}", wrapName, e.what());
            }
        }
    }

    // Copy packagefiles directory (contains custom meson.build for VMA)
    fs::path srcPackagefiles = editorSubprojects / "packagefiles";
    fs::path dstPackagefiles = subprojectsDir / "packagefiles";
    if (fs::exists(srcPackagefiles)) {
        try {
            fs::create_directories(dstPackagefiles);
            fs::copy(srcPackagefiles, dstPackagefiles,
                     fs::copy_options::recursive | fs::copy_options::overwrite_existing);
            Log::info("FileGenerator", "Copied packagefiles directory");
        } catch (const fs::filesystem_error& e) {
            Log::warning("FileGenerator", "Failed to copy packagefiles: {}", e.what());
        }
    }
}

void FileGenerator::generatePrimitives(
    NodeGraph& graph,
    primitives::Store& store,
    const std::filesystem::path& outputDir
) {
    namespace fs = std::filesystem;

    // === SET UP MODEL PATHS ===
    for (auto& vd : store.vertexDatas) {
        if (vd.name.empty()) continue;

        if (!vd.modelFilePath.empty()) {
            // Keep the model path as-is since it's already relative to project root
            // (e.g., "data/models/subfolder/model.gltf")

            // Clear the binary paths since we'll load from model file
            vd.vertexDataBinPath.clear();
            vd.indexDataBinPath.clear();

            Log::info("FileGenerator", "Set model path for {}: {} (geometry {})",
                vd.name, vd.modelFilePath, vd.geometryIndex);
        }
    }

    // === COPY ORIGINAL IMAGE FILES (for wuffs loading) ===
    std::filesystem::path imagesDir = outputDir.parent_path() / "data" / "images";
    std::filesystem::create_directories(imagesDir);

    for (auto& img : store.images) {
        if (img.name.empty()) continue;
        if (img.isSwapchainImage) continue;

        // If we have an original image path, copy the file and set the path for code gen
        if (!img.originalImagePath.empty()) {
            std::filesystem::path srcPath = img.originalImagePath;
            if (std::filesystem::exists(srcPath)) {
                std::string imageFileName = srcPath.filename().string();
                std::filesystem::path destPath = imagesDir / imageFileName;
                try {
                    std::filesystem::copy_file(srcPath, destPath,
                        std::filesystem::copy_options::overwrite_existing);
                    img.originalImagePath = "data/images/" + imageFileName;
                    Log::info("FileGenerator", "Copied image to: {}", destPath.string());
                } catch (const std::filesystem::filesystem_error& e) {
                    Log::error("FileGenerator", "Failed to copy image {}: {}",
                        srcPath.string(), e.what());
                }
            } else {
                Log::warning("FileGenerator", "Original image not found: {}",
                    srcPath.string());
            }
        }
        // Fallback: export texture data as binary if no original path (legacy support)
        else if (img.imageData != nullptr && img.imageSize > 0) {
            std::filesystem::path textureDir = outputDir.parent_path() / "data" / "textures";
            std::filesystem::create_directories(textureDir);
            std::string textureFileName = img.name + "_texture.bin";
            std::filesystem::path textureFilePath = textureDir / textureFileName;
            std::ofstream textureFile(textureFilePath, std::ios::binary);
            if (textureFile.is_open()) {
                textureFile.write(reinterpret_cast<const char*>(img.imageData), img.imageSize);
                textureFile.close();
                img.imageDataBinPath = "data/textures/" + textureFileName;
                Log::info("FileGenerator", "Exported texture data to: {}", textureFilePath.string());
            }
        }
    }

    // === COLLECT STRUCT DEFINITIONS FROM SHADER REFLECTION ===
    std::set<std::string> generatedStructNames;
    std::vector<ShaderTypes::StructInfo> allStructs;

    for (const auto& node : graph.nodes) {
        if (auto* pipeline = dynamic_cast<PipelineNode*>(node.get())) {
            const auto& reflection = pipeline->shaderReflection;

            for (const auto& s : reflection.cameraStructs) {
                if (generatedStructNames.find(s.structName) == generatedStructNames.end()) {
                    allStructs.push_back(s);
                    generatedStructNames.insert(s.structName);
                }
            }

            for (const auto& s : reflection.lightStructs) {
                if (generatedStructNames.find(s.structName) == generatedStructNames.end()) {
                    allStructs.push_back(s);
                    generatedStructNames.insert(s.structName);
                }
            }

            for (const auto& s : reflection.customStructs) {
                if (generatedStructNames.find(s.structName) == generatedStructNames.end()) {
                    allStructs.push_back(s);
                    generatedStructNames.insert(s.structName);
                }
            }
        }
    }

    // === GENERATE PRIMITIVES.H ===
    {
        auto outFile = outputDir / "primitives.h";
        std::ofstream out(outFile, std::ios::trunc);
        if (!out.is_open()) {
            Log::error("FileGenerator", "Cannot create file: {}", outFile.string());
            return;
        }

        print(out, "// vim:foldmethod=marker\n");
        print(out, "#pragma once\n\n");
        print(out, "#include <span>\n");
        print(out, "#include <vkDuck/vulkan_base.h>\n");
        print(out, "#include <vkDuck/library.h>\n");
        if (hasAnyCameras(store)) {
            print(out, "#include <vkDuck/camera_controller.h>\n");
        }
        if (hasModelFiles(store)) {
            print(out, "#include <vkDuck/model_loader.h>\n");
        }
        if (hasImageFiles(store)) {
            print(out, "#include <vkDuck/image_loader.h>\n");
        }
        print(out, "\n");

        if (!allStructs.empty()) {
            for (const auto& structInfo : allStructs) {
                primitiveGenerator.generateStructDefinition(structInfo, out);
                print(out, "\n");
            }
        }

        if (hasMovableCameras(store)) {
            for (const auto& camera : store.cameras) {
                if (camera.name.empty() || camera.isFixed()) continue;
                std::string safeName = sanitizeName(camera.name);
                print(out, "extern CameraController {};\nvoid init{}();\n", safeName, safeName);
            }
            print(out, "void updateCameraUBO(void* mappedMemory, const CameraController& camera);\n\n");
        }

        print(out,
              "void initializePrimitives(VkPhysicalDevice physicalDevice, VkDevice device, VmaAllocator allocator,\n"
              "                          VkQueue graphicsQueue, VkCommandPool commandPool,\n"
              "                          const VkExtent3D& swapChainExtent, VkFormat swapChainFormat,\n"
              "                          std::span<const VkImage> swapChainImages);\n"
        );
        print(out, "void cleanupPrimitives(VkDevice device, VmaAllocator allocator);\n\n");
        print(out,
              "void recordPrimitiveCommands(VkCommandBuffer cmdBuffer,\n"
              "                             uint32_t imageInFlightIndex);\n");

        Log::info("FileGenerator", "Generated: {}", outFile.string());
    }

    // === GENERATE PRIMITIVES.CPP ===
    {
        auto outFile = outputDir / "primitives.cpp";
        std::ofstream out(outFile, std::ios::trunc);
        if (!out.is_open()) {
            Log::error("FileGenerator", "Cannot create file: {}", outFile.string());
            return;
        }

        print(out, "// vim:foldmethod=marker\n");
        print(out, "#include \"primitives.h\"\n\n");
        primitiveGenerator.generateDefinitions(store, out);

        print(out,
              "void initializePrimitives(VkPhysicalDevice physicalDevice, VkDevice device, VmaAllocator allocator,\n"
              "                          VkQueue graphicsQueue, VkCommandPool commandPool,\n"
              "                          const VkExtent3D& swapChainExtent, VkFormat swapChainFormat,\n"
              "                          std::span<const VkImage> swapChainImages) {{\n"
        );
        primitiveGenerator.generateAll(store, out);

        if (hasMovableCameras(store)) {
            print(out, "\n");
            for (const auto& camera : store.cameras) {
                if (camera.name.empty() || camera.isFixed()) continue;
                print(out, "    init{}();\n", sanitizeName(camera.name));
            }
        }

        print(out, "}}\n\n");
        print(out, "void cleanupPrimitives(VkDevice device, VmaAllocator allocator) {{\n");
        primitiveGenerator.generateAllDestroy(store, out);
        print(out, "}}\n");

        print(out,
              "void recordPrimitiveCommands(VkCommandBuffer cmdBuffer,\n"
              "                             uint32_t imageInFlightIndex) {{\n"
        );
        primitiveGenerator.generateAllRecordCommands(store, out);
        print(out, "}}\n");

        Log::info("FileGenerator", "Generated: {}", outFile.string());
    }
}

void FileGenerator::generateRenderer(const primitives::Store& store, const std::filesystem::path& outputDir) {
    // Use inline template
    std::string content = RENDERER_TEMPLATE;

    // Generate camera-specific code based on what cameras exist
    std::string cameraKeyboardProcessing;
    std::string cameraMouseMotion;
    std::string cameraMouseButton;
    std::string cameraMouseScroll;
    std::string cameraAspectRatioUpdate;

    if (hasMovableCameras(store)) {
        // Generate aspect ratio update
        std::ostringstream aspectRatio;
        for (const auto& camera : store.cameras) {
            if (camera.name.empty() || camera.isFixed()) continue;
            std::string safeName = sanitizeName(camera.name);
            aspectRatio << "    " << safeName << ".setAspectRatio(aspectRatio);\n";
        }
        cameraAspectRatioUpdate = aspectRatio.str();

        // Generate keyboard processing using direct keyboard state polling
        std::ostringstream keyboardProc;
        keyboardProc << "\n        // Poll keyboard state directly for camera movement\n";
        keyboardProc << "        const bool* keyState = SDL_GetKeyboardState(nullptr);\n";
        keyboardProc << "        bool forward = keyState[SDL_SCANCODE_W] || keyState[SDL_SCANCODE_UP];\n";
        keyboardProc << "        bool backward = keyState[SDL_SCANCODE_S] || keyState[SDL_SCANCODE_DOWN];\n";
        keyboardProc << "        bool left = keyState[SDL_SCANCODE_A] || keyState[SDL_SCANCODE_LEFT];\n";
        keyboardProc << "        bool right = keyState[SDL_SCANCODE_D] || keyState[SDL_SCANCODE_RIGHT];\n\n";
        keyboardProc << "        if (forward || backward || left || right) {\n";
        for (const auto& camera : store.cameras) {
            if (camera.name.empty() || camera.isFixed()) continue;
            std::string safeName = sanitizeName(camera.name);
            keyboardProc << "            " << safeName << ".processKeyboard(m_deltaTime, forward, backward, left, right, false, false);\n";
        }
        keyboardProc << "        }\n";
        cameraKeyboardProcessing = keyboardProc.str();

        // Generate mouse motion handling
        std::ostringstream mouseMotion;
        for (const auto& camera : store.cameras) {
            if (camera.name.empty() || camera.isFixed()) continue;
            std::string safeName = sanitizeName(camera.name);
            mouseMotion << "    " << safeName << ".processMouseMotion(x, y);\n";
        }
        cameraMouseMotion = mouseMotion.str();

        // Generate mouse button handling
        std::ostringstream mouseButton;
        mouseButton << "    if (eventType == SDL_EVENT_MOUSE_BUTTON_DOWN && event.button == SDL_BUTTON_RIGHT) {\n";
        for (const auto& camera : store.cameras) {
            if (camera.name.empty() || camera.isFixed()) continue;
            std::string safeName = sanitizeName(camera.name);
            mouseButton << "        " << safeName << ".setMouseGrabbed(true);\n";
        }
        mouseButton << "    } else if (eventType == SDL_EVENT_MOUSE_BUTTON_UP && event.button == SDL_BUTTON_RIGHT) {\n";
        for (const auto& camera : store.cameras) {
            if (camera.name.empty() || camera.isFixed()) continue;
            std::string safeName = sanitizeName(camera.name);
            mouseButton << "        " << safeName << ".setMouseGrabbed(false);\n";
        }
        mouseButton << "    }\n";
        cameraMouseButton = mouseButton.str();

        // Generate mouse scroll handling
        std::ostringstream mouseScroll;
        for (const auto& camera : store.cameras) {
            if (camera.name.empty() || camera.isFixed()) continue;
            std::string safeName = sanitizeName(camera.name);
            mouseScroll << "    " << safeName << ".processScroll(delta);\n";
        }
        cameraMouseScroll = mouseScroll.str();
    }

    // Replace placeholders
    auto replaceAll = [](std::string& str, const std::string& from, const std::string& to) {
        size_t pos = 0;
        while ((pos = str.find(from, pos)) != std::string::npos) {
            str.replace(pos, from.length(), to);
            pos += to.length();
        }
    };

    replaceAll(content, "// === CAMERA_KEYBOARD_PROCESSING ===", cameraKeyboardProcessing);
    replaceAll(content, "// === CAMERA_MOUSE_MOTION ===", cameraMouseMotion);
    replaceAll(content, "// === CAMERA_MOUSE_BUTTON ===", cameraMouseButton);
    replaceAll(content, "// === CAMERA_MOUSE_SCROLL ===", cameraMouseScroll);
    replaceAll(content, "// === CAMERA_ASPECT_RATIO_UPDATE ===", cameraAspectRatioUpdate);

    auto outFile = outputDir / "vulkan_renderer.h";
    std::ofstream out(outFile, std::ios::trunc);
    if (!out.is_open()) {
        Log::error("FileGenerator", "Cannot create file: {}", outFile.string());
        return;
    }

    out << content;
    Log::info("FileGenerator", "Generated: {}", outFile.string());
}

void FileGenerator::generateMesonBuild(const primitives::Store& store, const std::filesystem::path& outputDir) {
    auto outFile = outputDir / "meson.build";
    std::ofstream out(outFile, std::ios::trunc);
    if (!out.is_open()) {
        Log::error("FileGenerator", "Cannot create file: {}", outFile.string());
        return;
    }

    bool hasCameras = hasMovableCameras(store);

    print(out,
        "project('vulkan_renderer', 'cpp',\n"
        "  version : '1.0.0',\n"
        "  default_options : [\n"
        "    'cpp_std=c++23',\n"
        "    'warning_level=0',\n"
        "    'buildtype=debugoptimized'\n"
        "  ]\n"
        ")\n\n"
        "# Use vkDuck from Vulkan-Editor (shared library)\n"
        "vkDuck_proj = subproject('vkDuck')\n"
        "vkDuck_dep = vkDuck_proj.get_variable('vkDuck_dep')\n\n"
        "# Source files (only project-specific generated code)\n"
        "sources = files(\n"
        "  'src/main.cpp',\n"
        "  'generated_files/primitives.cpp'"
    );

    if (hasCameras) {
        print(out, ",\n  'generated_files/camera_instances.cpp'");
    }

    print(out,
        "\n)\n\n"
        "# Include directories\n"
        "inc_dirs = include_directories('generated_files')\n\n"
        "# Compiler arguments\n"
        "cpp_args = []\n\n"
        "if host_machine.system() == 'darwin'\n"
        "  cpp_args += ['-DVK_USE_PLATFORM_MACOS_MVK']\n"
        "elif host_machine.system() == 'linux'\n"
        "  cpp_args += ['-DVK_USE_PLATFORM_XCB_KHR']\n"
        "elif host_machine.system() == 'windows'\n"
        "  cpp_args += ['-DVK_USE_PLATFORM_WIN32_KHR']\n"
        "endif\n\n"
        "# Build executable\n"
        "executable('main',\n"
        "  sources,\n"
        "  include_directories : [inc_dirs],\n"
        "  dependencies : [vkDuck_dep],\n"
        "  cpp_args : cpp_args,\n"
        "  install : true\n"
        ")\n"
    );

    Log::info("FileGenerator", "Generated: {}", outFile.string());
}

void FileGenerator::generateMain(const std::filesystem::path& outputDir) {
    auto outFile = outputDir / "main.cpp";
    std::ofstream out(outFile, std::ios::trunc);
    if (!out.is_open()) {
        Log::error("FileGenerator", "Cannot create file: {}", outFile.string());
        return;
    }

    out << MAIN_TEMPLATE;
    Log::info("FileGenerator", "Generated: {}", outFile.string());
}

bool FileGenerator::hasMovableCameras(const primitives::Store& store) const {
    for (const auto& camera : store.cameras) {
        if (!camera.name.empty() && !camera.isFixed()) {
            return true;
        }
    }
    return false;
}

bool FileGenerator::hasAnyCameras(const primitives::Store& store) const {
    for (const auto& camera : store.cameras) {
        if (!camera.name.empty()) {
            return true;
        }
    }
    return false;
}

bool FileGenerator::hasAnyLights(const primitives::Store& store) const {
    for (const auto& light : store.lights) {
        if (!light.name.empty()) {
            return true;
        }
    }
    return false;
}

void FileGenerator::generateCameraInstances(
    primitives::Store& store,
    const std::filesystem::path& outputDir
) {
    // Only generate camera_instances.cpp if we have movable cameras
    // The CameraController class itself is now in vkDuck
    if (!hasMovableCameras(store)) {
        Log::info("FileGenerator", "No movable cameras, skipping camera_instances.cpp");
        return;
    }

    auto outFile = outputDir / "camera_instances.cpp";
    std::ofstream out(outFile, std::ios::trunc);
    if (!out.is_open()) {
        Log::error("FileGenerator", "Cannot create file: {}", outFile.string());
        return;
    }

    // Include headers from vkDuck and primitives
    print(out, "// vim:foldmethod=marker\n");
    print(out, "// Generated camera instances and initialization\n");
    print(out, "#include <vkDuck/camera_controller.h>\n");
    print(out, "#include \"primitives.h\"\n\n");

    // Helper to format float with guaranteed decimal point for valid C++ literal
    auto flt = [](float v) {
        auto s = std::format("{:g}", v);
        if (s.find('.') == std::string::npos && s.find('e') == std::string::npos)
            s += ".0";
        return s + "f";
    };

    // Generate CameraController instances and init functions for each movable camera
    for (const auto& camera : store.cameras) {
        if (camera.name.empty() || camera.isFixed()) continue;

        const char* typeStr = camera.isFPS() ? "CameraType::FPS" : "CameraType::Orbital";
        std::string safeName = sanitizeName(camera.name);

        print(out, "CameraController {};\n\n", safeName);
        print(out, "void init{}() {{\n", safeName);
        print(out, "    {}.init(\n", safeName);
        print(out, "        {},\n", typeStr);
        print(out, "        glm::vec3({}, {}, {}),\n", flt(camera.position.x), flt(camera.position.y), flt(camera.position.z));
        print(out, "        glm::vec3({}, {}, {}),\n", flt(camera.target.x), flt(camera.target.y), flt(camera.target.z));
        print(out, "        glm::vec3({}, {}, {}),\n", flt(camera.up.x), flt(camera.up.y), flt(camera.up.z));
        print(out, "        {}, {}, {},\n", flt(camera.yaw), flt(camera.pitch), flt(camera.distance));
        print(out, "        {}, {}, {},\n", flt(camera.moveSpeed), flt(camera.rotateSpeed), flt(camera.zoomSpeed));
        print(out, "        {}, {}, {}\n", flt(camera.fov), flt(camera.nearPlane), flt(camera.farPlane));
        print(out, "    );\n");
        print(out, "}}\n\n");
    }

    // Generate the updateCameraUBO helper function
    print(out, "void updateCameraUBO(void* mappedMemory, const CameraController& camera) {{\n");
    print(out, "    Camera ubo;\n");
    print(out, "    ubo.view = camera.getViewMatrix();\n");
    print(out, "    ubo.invView = glm::inverse(ubo.view);\n");
    print(out, "    ubo.proj = camera.getProjectionMatrix();\n\n");
    print(out, "    memcpy(mappedMemory, &ubo, sizeof(Camera));\n");
    print(out, "}}\n");

    Log::info("FileGenerator", "Generated: {}", outFile.string());
}

void FileGenerator::generateShaders(
        const primitives::Store& store,
        const std::filesystem::path& outputDir
) {
    auto shaders = store.shaders |
        std::views::take(store.getShaderCount());
    for (auto&& shader : shaders) {
        auto outFile = outputDir / shader.getSpirvPath();
        std::ofstream out(outFile, std::ios::trunc | std::ios::binary);
        if (!out.is_open()) {
            Log::error("FileGenerator", "Cannot create file: {}", outFile.string());
            return;
        }

        out.write(
            reinterpret_cast<const char*>(shader.code.data()),
            shader.code.size() * sizeof(uint32_t));
        out.flush();

        Log::info("FileGenerator", "Generated shader: {}", outFile.string());
    }
}

bool FileGenerator::hasModelFiles(const primitives::Store& store) const {
    for (const auto& vd : store.vertexDatas) {
        if (!vd.name.empty() && !vd.modelFilePath.empty()) {
            return true;
        }
    }
    return false;
}

bool FileGenerator::hasImageFiles(const primitives::Store& store) const {
    for (const auto& img : store.images) {
        if (!img.name.empty() && !img.isSwapchainImage && !img.originalImagePath.empty()) {
            return true;
        }
    }
    return false;
}

// Note: generateImageLoader and generateModelLoader have been removed
// These files are now part of vkDuck shared library
