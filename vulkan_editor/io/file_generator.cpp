#include "file_generator.h"
#include "../graph/node_graph.h"
#include "../graph/pipeline_node.h"
#include "../util/logger.h"

#include <algorithm>
#include <filesystem>
#include <fstream>
#include <print>
#include <set>
#include <sstream>

using std::print;

namespace {

// Sanitize a name for use as a C++ identifier (replace spaces with underscores, etc.)
std::string sanitizeName(const std::string& name) {
    std::string result = name;
    std::replace(result.begin(), result.end(), ' ', '_');
    return result;
}

// Inline template for main.cpp
constexpr const char* MAIN_TEMPLATE = R"cpp(// Generated Vulkan Application
// This file is auto-generated by Vulkan Editor

#include "vulkan_renderer.h"

int main(int argc, char* argv[]) {
    VulkanRenderer renderer;

    try {
        renderer.init();
        renderer.run();
        renderer.cleanupRenderer();
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}
)cpp";

// Inline template for vulkan_renderer.h
constexpr const char* RENDERER_TEMPLATE = R"cpp(// vim:foldmethod=marker
#pragma once

#include "primitives.h"

// VulkanRenderer class {{{
class VulkanRenderer : public VulkanBase {
public:
    VulkanRenderer() = default;
    ~VulkanRenderer() override = default;

    void init();
    void run();
    void cleanupRenderer();

    std::vector<Object>& getObjects() { return m_objects; }
    const std::vector<Object>& getObjects() const { return m_objects; }

    void loadModel(const std::string& modelPath, const std::string& texturePath);

protected:
    void onWindowResized() override;
    void onKeyEvent(const SDL_KeyboardEvent& event) override;
    void onMouseMotion(float x, float y) override;
    void onMouseButton(const SDL_MouseButtonEvent& event, Uint32 eventType) override;
    void onMouseScroll(float delta) override;

private:
    void initPrimitives();
    void setupPipelines();
    void setupDescriptors();
    void drawFrame();
    void updateUniformBuffers(uint32_t currentImage);
    void updateCameraAspectRatios();

    std::vector<Object> m_objects;
    std::chrono::steady_clock::time_point m_lastFrameTime;
    float m_deltaTime = 0.0f;
};
// }}}

// VulkanRenderer implementation {{{
inline void VulkanRenderer::init() {
    initWindow("Vulkan Renderer");
    initVulkan();
    initPrimitives();
    setupPipelines();
    setupDescriptors();
    updateCameraAspectRatios();

    m_lastFrameTime = std::chrono::steady_clock::now();
    showWindow();
}

inline void VulkanRenderer::run() {
    while (!shouldClose()) {
        auto currentTime = std::chrono::steady_clock::now();
        m_deltaTime = std::chrono::duration<float>(currentTime - m_lastFrameTime).count();
        m_lastFrameTime = currentTime;

        pollEvents();
// === CAMERA_KEYBOARD_PROCESSING ===

        if (!isMinimized()) {
            drawFrame();
        }
    }

    waitIdle();
}

inline void VulkanRenderer::cleanupRenderer() {
    cleanupPrimitives(getDevice(), getAllocator());
    cleanup();
}

inline void VulkanRenderer::initPrimitives() {
    const auto& swapChain = getSwapChain();
    VkExtent3D extent{
        .width = swapChain.extent.width,
        .height = swapChain.extent.height,
        .depth = 1
    };
    initializePrimitives(
        getPhysicalDevice(),
        getDevice(),
        getAllocator(),
        getGraphicsQueue(),
        getCommandPool(),
        extent,
        swapChain.imageFormat,
        std::span<const VkImage>(swapChain.images.data(), swapChain.images.size())
    );
}

inline void VulkanRenderer::setupPipelines() {}

inline void VulkanRenderer::setupDescriptors() {}

inline void VulkanRenderer::drawFrame() {
    uint32_t imageIndex = beginFrame();
    if (imageIndex == UINT32_MAX) {
        return;
    }

    updateUniformBuffers(getCurrentFrame());

    VkCommandBuffer cmd = getCurrentCommandBuffer();
    vkResetCommandBuffer(cmd, 0);

    VkCommandBufferBeginInfo beginInfo{
        .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
        .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT
    };

    if (vkBeginCommandBuffer(cmd, &beginInfo) != VK_SUCCESS) {
        throw std::runtime_error("Failed to begin recording command buffer!");
    }

    recordPrimitiveCommands(cmd, imageIndex);

    if (vkEndCommandBuffer(cmd) != VK_SUCCESS) {
        throw std::runtime_error("Failed to record command buffer!");
    }

    endFrame(imageIndex);
}

inline void VulkanRenderer::updateUniformBuffers(uint32_t) {}

inline void VulkanRenderer::updateCameraAspectRatios() {
    const auto& swapChain = getSwapChain();
    float aspectRatio = static_cast<float>(swapChain.extent.width) / static_cast<float>(swapChain.extent.height);
// === CAMERA_ASPECT_RATIO_UPDATE ===
}

inline void VulkanRenderer::onWindowResized() {
    cleanupPrimitives(getDevice(), getAllocator());
    initPrimitives();
    updateCameraAspectRatios();
}

inline void VulkanRenderer::onKeyEvent(const SDL_KeyboardEvent& event) {
    if (event.down && event.scancode == SDL_SCANCODE_ESCAPE) {
        // Close application on Escape
    }
}

inline void VulkanRenderer::onMouseMotion(float x, float y) {
// === CAMERA_MOUSE_MOTION ===
}

inline void VulkanRenderer::onMouseButton(const SDL_MouseButtonEvent& event, Uint32 eventType) {
// === CAMERA_MOUSE_BUTTON ===
}

inline void VulkanRenderer::onMouseScroll(float delta) {
// === CAMERA_MOUSE_SCROLL ===
}

inline void VulkanRenderer::loadModel(const std::string&, const std::string&) {}
// }}}
)cpp";

} // namespace

void FileGenerator::generateProject(
    NodeGraph& graph,
    primitives::Store& store,
    const std::filesystem::path& outputDirectory
) {
    std::filesystem::path generatedDir = outputDirectory;
    std::filesystem::path projectRoot = generatedDir.parent_path();
    std::filesystem::path srcDir = projectRoot / "src";

    // Create directory structure
    std::filesystem::create_directories(generatedDir);
    std::filesystem::create_directories(srcDir);

    // Validate primitive names
    store.validateUniqueNames();

    // Build dependencies for struct generation
    graph.buildDependencies();

    // Generate only project-specific files (shared code is now in vkDuck)
    generateCameraInstances(store, generatedDir);
    generatePrimitives(graph, store, generatedDir);
    generateRenderer(store, generatedDir);
    generateShaders(store, projectRoot / "compiled_shaders");

    // Generate main.cpp in src/
    generateMain(srcDir);

    // Link SDK and generate meson.build at project root
    generateSDKLinks(projectRoot);
    generateMesonBuild(store, projectRoot);

    Log::info("FileGenerator", "Project generated to: {}", projectRoot.string());
}

void FileGenerator::generateSDKLinks(const std::filesystem::path& projectRoot) {
    namespace fs = std::filesystem;

    fs::path editorRoot = fs::current_path();
    fs::path buildDir = editorRoot / "build";
    fs::path subprojectsDir = projectRoot / "subprojects";
    fs::path projectLib = projectRoot / "lib";
    fs::path projectInclude = projectRoot / "include";
    fs::path projectLicenses = projectRoot / "licenses";

    // Create directories
    fs::create_directories(subprojectsDir);
    fs::create_directories(projectLib);
    fs::create_directories(projectInclude);
    fs::create_directories(projectLicenses);

    std::error_code ec;

    // === Determine platform-specific library name ===
#ifdef _WIN32
    const std::string libName = "vkDuck.lib";
#else
    const std::string libName = "libvkDuck.a";
#endif

    // === Link pre-compiled vkDuck library from build directory ===
    fs::path builtLib = buildDir / "subprojects" / "vkDuck" / libName;
    if (!fs::exists(builtLib)) {
        Log::error("FileGenerator", "vkDuck library not built at {}. Build the editor first with 'meson compile -C build'", builtLib.string());
        return;
    }

    fs::path libLink = projectLib / libName;
    if (fs::exists(libLink, ec) || fs::is_symlink(libLink)) {
        fs::remove(libLink, ec);
    }

    try {
        fs::create_symlink(builtLib, libLink);
        Log::info("FileGenerator", "Linked vkDuck library from build directory");
    } catch (const fs::filesystem_error& e) {
        // Symlinks may fail on Windows without admin privileges
        fs::copy_file(builtLib, libLink, fs::copy_options::overwrite_existing);
        Log::info("FileGenerator", "Copied vkDuck library from build directory");
    }

    // === Link vkDuck headers from source ===
    fs::path vkDuckHeaders = editorRoot / "subprojects" / "vkDuck" / "include" / "vkDuck";
    fs::path vkDuckLink = projectInclude / "vkDuck";
    if (fs::exists(vkDuckLink, ec) || fs::is_symlink(vkDuckLink)) {
        fs::remove_all(vkDuckLink, ec);
    }

    try {
        fs::create_directory_symlink(vkDuckHeaders, vkDuckLink);
        Log::info("FileGenerator", "Linked vkDuck headers");
    } catch (const fs::filesystem_error& e) {
        fs::copy(vkDuckHeaders, vkDuckLink, fs::copy_options::recursive);
        Log::info("FileGenerator", "Copied vkDuck headers");
    }

    // === Copy wrap files for dependencies (Meson handles the rest) ===
    fs::path editorSubprojects = editorRoot / "subprojects";
    std::vector<std::string> wrapFiles = {
        "sdl3.wrap",
        "glm.wrap",
        "vulkan-memory-allocator.wrap"
    };

    for (const auto& wrapName : wrapFiles) {
        fs::path src = editorSubprojects / wrapName;
        fs::path dst = subprojectsDir / wrapName;
        if (fs::exists(src)) {
            try {
                fs::copy_file(src, dst, fs::copy_options::overwrite_existing);
                Log::info("FileGenerator", "Copied {}", wrapName);
            } catch (const fs::filesystem_error& e) {
                Log::warning("FileGenerator", "Failed to copy {}: {}", wrapName, e.what());
            }
        }
    }

    // Copy only VMA packagefiles (not imgui/imgui-node-editor which are editor-only)
    fs::path srcVmaPackage = editorSubprojects / "packagefiles" / "vulkan-memory-allocator";
    fs::path dstVmaPackage = subprojectsDir / "packagefiles" / "vulkan-memory-allocator";
    if (fs::exists(srcVmaPackage)) {
        try {
            fs::create_directories(dstVmaPackage.parent_path());
            if (fs::exists(dstVmaPackage)) {
                fs::remove_all(dstVmaPackage);
            }
            fs::copy(srcVmaPackage, dstVmaPackage, fs::copy_options::recursive);
            Log::info("FileGenerator", "Copied VMA packagefiles");
        } catch (const fs::filesystem_error& e) {
            Log::warning("FileGenerator", "Failed to copy VMA packagefiles: {}", e.what());
        }
    }

    // === Copy licenses ===
    fs::path licensesDir = editorRoot / "licenses";
    if (fs::exists(licensesDir)) {
        try {
            for (const auto& entry : fs::directory_iterator(licensesDir)) {
                if (entry.is_directory()) {
                    // Each license is in a subdirectory with LICENSE file
                    fs::path licenseFile = entry.path() / "LICENSE";
                    if (fs::exists(licenseFile)) {
                        std::string name = entry.path().filename().string() + "-LICENSE";
                        fs::copy_file(licenseFile, projectLicenses / name, fs::copy_options::overwrite_existing);
                    }
                }
            }
            // Copy main project license
            fs::path mainLicense = editorRoot / "LICENSE";
            if (fs::exists(mainLicense)) {
                fs::copy_file(mainLicense, projectLicenses / "vkDuck-LICENSE", fs::copy_options::overwrite_existing);
            }
            Log::info("FileGenerator", "Copied licenses");
        } catch (const fs::filesystem_error& e) {
            Log::warning("FileGenerator", "Failed to copy licenses: {}", e.what());
        }
    }
}

void FileGenerator::generatePrimitives(
    NodeGraph& graph,
    primitives::Store& store,
    const std::filesystem::path& outputDir
) {
    namespace fs = std::filesystem;

    // === SET UP MODEL PATHS ===
    for (auto& vd : store.vertexDatas) {
        if (vd.name.empty()) continue;

        if (!vd.modelFilePath.empty()) {
            // Keep the model path as-is since it's already relative to project root
            // (e.g., "data/models/subfolder/model.gltf")

            // Clear the binary paths since we'll load from model file
            vd.vertexDataBinPath.clear();
            vd.indexDataBinPath.clear();

            Log::info("FileGenerator", "Set model path for {}: {} (geometry {})",
                vd.name, vd.modelFilePath, vd.geometryIndex);
        }
    }

    // === COPY ORIGINAL IMAGE FILES (for wuffs loading) ===
    std::filesystem::path imagesDir = outputDir.parent_path() / "data" / "images";
    std::filesystem::create_directories(imagesDir);

    for (auto& img : store.images) {
        if (img.name.empty()) continue;
        if (img.isSwapchainImage) continue;

        // If we have an original image path, copy the file and set the path for code gen
        if (!img.originalImagePath.empty()) {
            std::filesystem::path srcPath = img.originalImagePath;
            if (std::filesystem::exists(srcPath)) {
                std::string imageFileName = srcPath.filename().string();
                std::filesystem::path destPath = imagesDir / imageFileName;
                try {
                    std::filesystem::copy_file(srcPath, destPath,
                        std::filesystem::copy_options::overwrite_existing);
                    img.originalImagePath = "data/images/" + imageFileName;
                    Log::info("FileGenerator", "Copied image to: {}", destPath.string());
                } catch (const std::filesystem::filesystem_error& e) {
                    Log::error("FileGenerator", "Failed to copy image {}: {}",
                        srcPath.string(), e.what());
                }
            } else {
                Log::warning("FileGenerator", "Original image not found: {}",
                    srcPath.string());
            }
        }
        // Fallback: export texture data as binary if no original path (legacy support)
        else if (img.imageData != nullptr && img.imageSize > 0) {
            std::filesystem::path textureDir = outputDir.parent_path() / "data" / "textures";
            std::filesystem::create_directories(textureDir);
            std::string textureFileName = img.name + "_texture.bin";
            std::filesystem::path textureFilePath = textureDir / textureFileName;
            std::ofstream textureFile(textureFilePath, std::ios::binary);
            if (textureFile.is_open()) {
                textureFile.write(reinterpret_cast<const char*>(img.imageData), img.imageSize);
                textureFile.close();
                img.imageDataBinPath = "data/textures/" + textureFileName;
                Log::info("FileGenerator", "Exported texture data to: {}", textureFilePath.string());
            }
        }
    }

    // === COLLECT STRUCT DEFINITIONS FROM SHADER REFLECTION ===
    std::set<std::string> generatedStructNames;
    std::vector<ShaderTypes::StructInfo> allStructs;

    for (const auto& node : graph.nodes) {
        if (auto* pipeline = dynamic_cast<PipelineNode*>(node.get())) {
            const auto& reflection = pipeline->shaderReflection;

            for (const auto& s : reflection.cameraStructs) {
                if (generatedStructNames.find(s.structName) == generatedStructNames.end()) {
                    allStructs.push_back(s);
                    generatedStructNames.insert(s.structName);
                }
            }

            for (const auto& s : reflection.lightStructs) {
                if (generatedStructNames.find(s.structName) == generatedStructNames.end()) {
                    allStructs.push_back(s);
                    generatedStructNames.insert(s.structName);
                }
            }

            for (const auto& s : reflection.customStructs) {
                if (generatedStructNames.find(s.structName) == generatedStructNames.end()) {
                    allStructs.push_back(s);
                    generatedStructNames.insert(s.structName);
                }
            }
        }
    }

    // === GENERATE PRIMITIVES.H ===
    {
        auto outFile = outputDir / "primitives.h";
        std::ofstream out(outFile, std::ios::trunc);
        if (!out.is_open()) {
            Log::error("FileGenerator", "Cannot create file: {}", outFile.string());
            return;
        }

        print(out, "// vim:foldmethod=marker\n");
        print(out, "#pragma once\n\n");
        print(out, "#include <span>\n");
        print(out, "#include <vkDuck/vulkan_base.h>\n");
        print(out, "#include <vkDuck/library.h>\n");
        if (hasAnyCameras(store)) {
            print(out, "#include <vkDuck/camera_controller.h>\n");
        }
        if (hasModelFiles(store)) {
            print(out, "#include <vkDuck/model_loader.h>\n");
        }
        if (hasImageFiles(store)) {
            print(out, "#include <vkDuck/image_loader.h>\n");
        }
        print(out, "\n");

        if (!allStructs.empty()) {
            for (const auto& structInfo : allStructs) {
                primitiveGenerator.generateStructDefinition(structInfo, out);
                print(out, "\n");
            }
        }

        if (hasMovableCameras(store)) {
            for (const auto& camera : store.cameras) {
                if (camera.name.empty() || camera.isFixed()) continue;
                std::string safeName = sanitizeName(camera.name);
                print(out, "extern CameraController {};\nvoid init{}();\n", safeName, safeName);
            }
            print(out, "void updateCameraUBO(void* mappedMemory, const CameraController& camera);\n\n");
        }

        print(out,
              "void initializePrimitives(VkPhysicalDevice physicalDevice, VkDevice device, VmaAllocator allocator,\n"
              "                          VkQueue graphicsQueue, VkCommandPool commandPool,\n"
              "                          const VkExtent3D& swapChainExtent, VkFormat swapChainFormat,\n"
              "                          std::span<const VkImage> swapChainImages);\n"
        );
        print(out, "void cleanupPrimitives(VkDevice device, VmaAllocator allocator);\n\n");
        print(out,
              "void recordPrimitiveCommands(VkCommandBuffer cmdBuffer,\n"
              "                             uint32_t imageInFlightIndex);\n");

        Log::info("FileGenerator", "Generated: {}", outFile.string());
    }

    // === GENERATE PRIMITIVES.CPP ===
    {
        auto outFile = outputDir / "primitives.cpp";
        std::ofstream out(outFile, std::ios::trunc);
        if (!out.is_open()) {
            Log::error("FileGenerator", "Cannot create file: {}", outFile.string());
            return;
        }

        print(out, "// vim:foldmethod=marker\n");
        print(out, "#include <filesystem>\n");
        print(out, "#include \"primitives.h\"\n\n");
        primitiveGenerator.generateDefinitions(store, out);

        print(out,
              "void initializePrimitives(VkPhysicalDevice physicalDevice, VkDevice device, VmaAllocator allocator,\n"
              "                          VkQueue graphicsQueue, VkCommandPool commandPool,\n"
              "                          const VkExtent3D& swapChainExtent, VkFormat swapChainFormat,\n"
              "                          std::span<const VkImage> swapChainImages) {{\n"
        );
        primitiveGenerator.generateAll(store, out);

        if (hasMovableCameras(store)) {
            print(out, "\n");
            for (const auto& camera : store.cameras) {
                if (camera.name.empty() || camera.isFixed()) continue;
                print(out, "    init{}();\n", sanitizeName(camera.name));
            }
        }

        print(out, "}}\n\n");
        print(out, "void cleanupPrimitives(VkDevice device, VmaAllocator allocator) {{\n");
        primitiveGenerator.generateAllDestroy(store, out);
        print(out, "}}\n");

        print(out,
              "void recordPrimitiveCommands(VkCommandBuffer cmdBuffer,\n"
              "                             uint32_t imageInFlightIndex) {{\n"
        );
        primitiveGenerator.generateAllRecordCommands(store, out);
        print(out, "}}\n");

        Log::info("FileGenerator", "Generated: {}", outFile.string());
    }
}

void FileGenerator::generateRenderer(const primitives::Store& store, const std::filesystem::path& outputDir) {
    // Use inline template
    std::string content = RENDERER_TEMPLATE;

    // Generate camera-specific code based on what cameras exist
    std::string cameraKeyboardProcessing;
    std::string cameraMouseMotion;
    std::string cameraMouseButton;
    std::string cameraMouseScroll;
    std::string cameraAspectRatioUpdate;

    if (hasMovableCameras(store)) {
        // Generate aspect ratio update
        std::ostringstream aspectRatio;
        for (const auto& camera : store.cameras) {
            if (camera.name.empty() || camera.isFixed()) continue;
            std::string safeName = sanitizeName(camera.name);
            aspectRatio << "    " << safeName << ".setAspectRatio(aspectRatio);\n";
        }
        cameraAspectRatioUpdate = aspectRatio.str();

        // Generate keyboard processing using direct keyboard state polling
        std::ostringstream keyboardProc;
        keyboardProc << "\n        // Poll keyboard state directly for camera movement\n";
        keyboardProc << "        const bool* keyState = SDL_GetKeyboardState(nullptr);\n";
        keyboardProc << "        bool forward = keyState[SDL_SCANCODE_W] || keyState[SDL_SCANCODE_UP];\n";
        keyboardProc << "        bool backward = keyState[SDL_SCANCODE_S] || keyState[SDL_SCANCODE_DOWN];\n";
        keyboardProc << "        bool left = keyState[SDL_SCANCODE_A] || keyState[SDL_SCANCODE_LEFT];\n";
        keyboardProc << "        bool right = keyState[SDL_SCANCODE_D] || keyState[SDL_SCANCODE_RIGHT];\n\n";
        keyboardProc << "        if (forward || backward || left || right) {\n";
        for (const auto& camera : store.cameras) {
            if (camera.name.empty() || camera.isFixed()) continue;
            std::string safeName = sanitizeName(camera.name);
            keyboardProc << "            " << safeName << ".processKeyboard(m_deltaTime, forward, backward, left, right, false, false);\n";
        }
        keyboardProc << "        }\n";
        cameraKeyboardProcessing = keyboardProc.str();

        // Generate mouse motion handling
        std::ostringstream mouseMotion;
        for (const auto& camera : store.cameras) {
            if (camera.name.empty() || camera.isFixed()) continue;
            std::string safeName = sanitizeName(camera.name);
            mouseMotion << "    " << safeName << ".processMouseMotion(x, y);\n";
        }
        cameraMouseMotion = mouseMotion.str();

        // Generate mouse button handling
        std::ostringstream mouseButton;
        mouseButton << "    if (eventType == SDL_EVENT_MOUSE_BUTTON_DOWN && event.button == SDL_BUTTON_RIGHT) {\n";
        for (const auto& camera : store.cameras) {
            if (camera.name.empty() || camera.isFixed()) continue;
            std::string safeName = sanitizeName(camera.name);
            mouseButton << "        " << safeName << ".setMouseGrabbed(true);\n";
        }
        mouseButton << "    } else if (eventType == SDL_EVENT_MOUSE_BUTTON_UP && event.button == SDL_BUTTON_RIGHT) {\n";
        for (const auto& camera : store.cameras) {
            if (camera.name.empty() || camera.isFixed()) continue;
            std::string safeName = sanitizeName(camera.name);
            mouseButton << "        " << safeName << ".setMouseGrabbed(false);\n";
        }
        mouseButton << "    }\n";
        cameraMouseButton = mouseButton.str();

        // Generate mouse scroll handling
        std::ostringstream mouseScroll;
        for (const auto& camera : store.cameras) {
            if (camera.name.empty() || camera.isFixed()) continue;
            std::string safeName = sanitizeName(camera.name);
            mouseScroll << "    " << safeName << ".processScroll(delta);\n";
        }
        cameraMouseScroll = mouseScroll.str();
    }

    // Replace placeholders
    auto replaceAll = [](std::string& str, const std::string& from, const std::string& to) {
        size_t pos = 0;
        while ((pos = str.find(from, pos)) != std::string::npos) {
            str.replace(pos, from.length(), to);
            pos += to.length();
        }
    };

    replaceAll(content, "// === CAMERA_KEYBOARD_PROCESSING ===", cameraKeyboardProcessing);
    replaceAll(content, "// === CAMERA_MOUSE_MOTION ===", cameraMouseMotion);
    replaceAll(content, "// === CAMERA_MOUSE_BUTTON ===", cameraMouseButton);
    replaceAll(content, "// === CAMERA_MOUSE_SCROLL ===", cameraMouseScroll);
    replaceAll(content, "// === CAMERA_ASPECT_RATIO_UPDATE ===", cameraAspectRatioUpdate);

    auto outFile = outputDir / "vulkan_renderer.h";
    std::ofstream out(outFile, std::ios::trunc);
    if (!out.is_open()) {
        Log::error("FileGenerator", "Cannot create file: {}", outFile.string());
        return;
    }

    out << content;
    Log::info("FileGenerator", "Generated: {}", outFile.string());
}

void FileGenerator::generateMesonBuild(const primitives::Store& store, const std::filesystem::path& outputDir) {
    auto outFile = outputDir / "meson.build";
    std::ofstream out(outFile, std::ios::trunc);
    if (!out.is_open()) {
        Log::error("FileGenerator", "Cannot create file: {}", outFile.string());
        return;
    }

    bool hasCameras = hasMovableCameras(store);

    print(out,
        "project('vulkan_renderer', 'cpp',\n"
        "  version : '1.0.0',\n"
        "  default_options : [\n"
        "    'cpp_std=c++23',\n"
        "    'warning_level=0',\n"
        "    'buildtype=debugoptimized'\n"
        "  ]\n"
        ")\n\n"
        "# Dependencies (via Meson wraps)\n"
        "vulkan_dep = dependency('vulkan')\n"
        "sdl3_dep = dependency('sdl3')\n"
        "glm_dep = dependency('glm')\n"
        "vma_dep = dependency('vulkan-memory-allocator', include_type: 'system')\n\n"
        "# Pre-compiled vkDuck library (built with Vulkan-Editor)\n"
        "vkDuck_inc = include_directories('include')\n"
        "cpp = meson.get_compiler('cpp')\n"
        "vkDuck_lib = cpp.find_library('vkDuck',\n"
        "  dirs: meson.current_source_dir() / 'lib',\n"
        "  static: true\n"
        ")\n\n"
        "# Combine vkDuck with its dependencies\n"
        "vkDuck_dep = declare_dependency(\n"
        "  include_directories: vkDuck_inc,\n"
        "  dependencies: [vkDuck_lib, vulkan_dep, sdl3_dep, glm_dep, vma_dep]\n"
        ")\n\n"
        "# Source files (project-specific generated code)\n"
        "sources = files(\n"
        "  'src/main.cpp',\n"
        "  'generated_files/primitives.cpp'"
    );

    if (hasCameras) {
        print(out, ",\n  'generated_files/camera_instances.cpp'");
    }

    print(out,
        "\n)\n\n"
        "# Include directories\n"
        "inc_dirs = include_directories('generated_files')\n\n"
        "# Compiler arguments\n"
        "cpp_args = ['-DVKDUCK_NO_VMA_IMPLEMENTATION']\n\n"
        "if host_machine.system() == 'darwin'\n"
        "  cpp_args += ['-DVK_USE_PLATFORM_MACOS_MVK']\n"
        "elif host_machine.system() == 'linux'\n"
        "  cpp_args += ['-DVK_USE_PLATFORM_XCB_KHR']\n"
        "elif host_machine.system() == 'windows'\n"
        "  cpp_args += ['-DVK_USE_PLATFORM_WIN32_KHR']\n"
        "endif\n\n"
        "# Build executable\n"
        "executable('main',\n"
        "  sources,\n"
        "  include_directories : [inc_dirs],\n"
        "  dependencies : [vkDuck_dep],\n"
        "  cpp_args : cpp_args,\n"
        "  install : true\n"
        ")\n"
    );

    Log::info("FileGenerator", "Generated: {}", outFile.string());
}

void FileGenerator::generateMain(const std::filesystem::path& outputDir) {
    auto outFile = outputDir / "main.cpp";
    std::ofstream out(outFile, std::ios::trunc);
    if (!out.is_open()) {
        Log::error("FileGenerator", "Cannot create file: {}", outFile.string());
        return;
    }

    out << MAIN_TEMPLATE;
    Log::info("FileGenerator", "Generated: {}", outFile.string());
}

bool FileGenerator::hasMovableCameras(const primitives::Store& store) const {
    for (const auto& camera : store.cameras) {
        if (!camera.name.empty() && !camera.isFixed()) {
            return true;
        }
    }
    return false;
}

bool FileGenerator::hasAnyCameras(const primitives::Store& store) const {
    for (const auto& camera : store.cameras) {
        if (!camera.name.empty()) {
            return true;
        }
    }
    return false;
}

bool FileGenerator::hasAnyLights(const primitives::Store& store) const {
    for (const auto& light : store.lights) {
        if (!light.name.empty()) {
            return true;
        }
    }
    return false;
}

void FileGenerator::generateCameraInstances(
    primitives::Store& store,
    const std::filesystem::path& outputDir
) {
    // Only generate camera_instances.cpp if we have movable cameras
    // The CameraController class itself is now in vkDuck
    if (!hasMovableCameras(store)) {
        Log::info("FileGenerator", "No movable cameras, skipping camera_instances.cpp");
        return;
    }

    auto outFile = outputDir / "camera_instances.cpp";
    std::ofstream out(outFile, std::ios::trunc);
    if (!out.is_open()) {
        Log::error("FileGenerator", "Cannot create file: {}", outFile.string());
        return;
    }

    // Include headers from vkDuck and primitives
    print(out, "// vim:foldmethod=marker\n");
    print(out, "// Generated camera instances and initialization\n");
    print(out, "#include <vkDuck/camera_controller.h>\n");
    print(out, "#include \"primitives.h\"\n\n");

    // Helper to format float with guaranteed decimal point for valid C++ literal
    auto flt = [](float v) {
        auto s = std::format("{:g}", v);
        if (s.find('.') == std::string::npos && s.find('e') == std::string::npos)
            s += ".0";
        return s + "f";
    };

    // Generate CameraController instances and init functions for each movable camera
    for (const auto& camera : store.cameras) {
        if (camera.name.empty() || camera.isFixed()) continue;

        const char* typeStr = camera.isFPS() ? "CameraType::FPS" : "CameraType::Orbital";
        std::string safeName = sanitizeName(camera.name);

        print(out, "CameraController {};\n\n", safeName);
        print(out, "void init{}() {{\n", safeName);
        print(out, "    {}.init(\n", safeName);
        print(out, "        {},\n", typeStr);
        print(out, "        glm::vec3({}, {}, {}),\n", flt(camera.position.x), flt(camera.position.y), flt(camera.position.z));
        print(out, "        glm::vec3({}, {}, {}),\n", flt(camera.target.x), flt(camera.target.y), flt(camera.target.z));
        print(out, "        glm::vec3({}, {}, {}),\n", flt(camera.up.x), flt(camera.up.y), flt(camera.up.z));
        print(out, "        {}, {}, {},\n", flt(camera.yaw), flt(camera.pitch), flt(camera.distance));
        print(out, "        {}, {}, {},\n", flt(camera.moveSpeed), flt(camera.rotateSpeed), flt(camera.zoomSpeed));
        print(out, "        {}, {}, {}\n", flt(camera.fov), flt(camera.nearPlane), flt(camera.farPlane));
        print(out, "    );\n");
        print(out, "}}\n\n");
    }

    // Generate the updateCameraUBO helper function
    print(out, "void updateCameraUBO(void* mappedMemory, const CameraController& camera) {{\n");
    print(out, "    Camera ubo;\n");
    print(out, "    ubo.view = camera.getViewMatrix();\n");
    print(out, "    ubo.invView = glm::inverse(ubo.view);\n");
    print(out, "    ubo.proj = camera.getProjectionMatrix();\n\n");
    print(out, "    memcpy(mappedMemory, &ubo, sizeof(Camera));\n");
    print(out, "}}\n");

    Log::info("FileGenerator", "Generated: {}", outFile.string());
}

void FileGenerator::generateShaders(
        const primitives::Store& store,
        const std::filesystem::path& outputDir
) {
    auto shaders = store.shaders |
        std::views::take(store.getShaderCount());
    for (auto&& shader : shaders) {
        auto outFile = outputDir / shader.getSpirvPath();
        std::ofstream out(outFile, std::ios::trunc | std::ios::binary);
        if (!out.is_open()) {
            Log::error("FileGenerator", "Cannot create file: {}", outFile.string());
            return;
        }

        out.write(
            reinterpret_cast<const char*>(shader.code.data()),
            shader.code.size() * sizeof(uint32_t));
        out.flush();

        Log::info("FileGenerator", "Generated shader: {}", outFile.string());
    }
}

bool FileGenerator::hasModelFiles(const primitives::Store& store) const {
    for (const auto& vd : store.vertexDatas) {
        if (!vd.name.empty() && !vd.modelFilePath.empty()) {
            return true;
        }
    }
    return false;
}

bool FileGenerator::hasImageFiles(const primitives::Store& store) const {
    for (const auto& img : store.images) {
        if (!img.name.empty() && !img.isSwapchainImage && !img.originalImagePath.empty()) {
            return true;
        }
    }
    return false;
}

// Note: generateImageLoader and generateModelLoader have been removed
// These files are now part of vkDuck shared library
